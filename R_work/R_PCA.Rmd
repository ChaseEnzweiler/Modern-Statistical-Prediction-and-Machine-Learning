---
title: "PCA"
author: "Chase Enzweiler"
date: "9/18/2017"
output: html_document
---

# Principal Component Analysis

\
```{r}
wholesale <- read.csv("~/Desktop/stat 154/wholesale.csv")

```
\
convert channel and region variables to factors

```{r}
# factor and horeca = 1 and retail = 2
wholesale$Channel[wholesale$Channel == 1] <- "Horeca"
wholesale$Channel[wholesale$Channel == 2] <- "Retail"
wholesale$Channel <- as.factor(wholesale$Channel)

# 1= lisbon, 2 = oporto, 3 = other
wholesale$Region[wholesale$Region == 1] <- "Lisbon"
wholesale$Region[wholesale$Region == 2] <- "Oporto"
wholesale$Region[wholesale$Region == 3] <- "Other"
wholesale$Region <- as.factor(wholesale$Region)

```
\
perform exploratory data analysis
```{r}
#summary statistics
summary(wholesale)

#boxplots for quant. varibles and standardized quant. variables
boxplot(wholesale[,3:8])
boxplot(scale(wholesale[,3:8]))

# correlation matrix
cor(wholesale[,3:8])

# pairs plot
pairs(wholesale[,3:8])

```
\
we see not a lot of spread in the different scatterplots ecept for the the milk and grocery scatter plot which has the closest resemblance to a linear relationship.


### PCA with prcomp()


\
What are the differences between prcomp() and princomp()?
\
Princomp() is calculated using eigen decomposition of a correlation matrix (1/n)t(x)x or covariance matrix. it is done for compatibility with SPLUS. it uses divisor n for the covariance matrix. It prints results in a nice format to and has plot methods to produce scree plots and a biplot method. May not necesarilly center data beforehand? prints the number of observations
\
prcomp() is calculated using singular value decomposition and not eigen decompostition on a covariance matrix. SVD is used for numerical accuracy. print method prints in a nice format and has a plot method for scree plots. Variances are computed using the divisor N - 1
\
it would be better to use prcomp() most of the time because it uses SVD which produces better numerical accuracy. princomp may be better sometimes if we wanted to create a biplot because it has a biplot method. 
\
## Stages of PCA

```{r}
pca <- prcomp(wholesale[,3:8], scale. = TRUE)

# eigenvalues are the variances of the pc's
eigenvalues <- (pca$sdev)^2
proportion <- eigenvalues/6

cum_prop <- c(proportion[1])

for(i in 2:6){
  cum_prop <- append(cum_prop, sum(proportion[1:i]))
}

eigenvalue_table <- cbind(eigenvalues, proportion, cum_prop)
rownames(eigenvalue_table) <- paste("PC", 1:6, sep = "")

eigenvalue_table <- as.table(eigenvalue_table)

eigenvalue_table

barplot(eigenvalue_table[,1], main = "barchart of eigenvalues")
```
\
about 43 percent of the total variance is captured din the first PC. About 33 percent of the total variance is captured in the second PC. About 77 percent of the total variation is captured by the first two PC's
\


### Choosing the number of components



* to capture 70 percent of the total variatiion we would choose two PC's
```{r}
#eigenvalue average
sum(eigenvalues)/6

plot(1:6, eigenvalues, ylab = "Eigenvalues", type = "b", xlab = "Number of Principal Components", main = "Scree-Plot")

```
/
* using the average eigenvalue criterion where our average is 1, we would keep the first two PC's
* kaiser rule is the same as above keep the first 2 PC's
* With jollifes rule we still keep the first two PC's
* looking at the scree plot we could keep the first two or three PC's

## Variable loadings and correlations with PC's



```{r}
# calculate the correlations between the active variables and the Pc's

correlations <- cor(wholesale[,3:8], pca$x)

```
\
graph the circle of correlations
```{r}
library(ggplot2)

correlations <- as.data.frame(correlations)

radians <- seq(0, 2*pi, length = 100)
circle_frame <- data.frame(x = sin(radians), y = cos(radians))

ggplot(data = correlations, aes(PC1, PC2)) + geom_segment(data = correlations, aes(x = 0, y = 0, xend = PC1, yend = PC2), arrow = arrow(length = unit(0.2, "cm"))) + geom_polygon(aes(x,y), data = circle_frame, color = "black", fill = NA)  + 
  geom_text(data = correlations, label = rownames(correlations)) 

# contributions of observations
contr <- t(t(pca$x ^ 2) / eigenvalues)

contr[1:6,]
```
\ 
delete observations with contributions of 10 or more on PC1

```{r}
rows_to_del <- which(contr[,1] >= 10)

wholesale2 <- wholesale[-rows_to_del,]

```
\
now perform all the before steps on the data wholesale2
\
```{r}
pca2 <- prcomp(wholesale2[,3:8], scale. = TRUE)

eigenvalues2 <- pca2$sdev ^ 2

proportion2 <- eigenvalues2/6

cum_prop2 <- c(proportion2[1])

for(i in 2:6){
  cum_prop <- append(cum_prop2, sum(proportion2[1:i]))
}

plot(1:6, eigenvalues2, ylab = "Eigenvalues2", type = "b", xlab = "Number of Principal Components", main = "Scree-Plot2")

correlations2 <- cor(wholesale2[,3:8], pca2$x)


correlations2 <- as.data.frame(correlations2)

radians <- seq(0, 2*pi, length = 100)
circle_frame <- data.frame(x = sin(radians), y = cos(radians))

ggplot(data = correlations2, aes(PC1, PC2)) + geom_segment(data = correlations2, aes(x = 0, y = 0, xend = PC1, yend = PC2), arrow = arrow(length = unit(0.2, "cm"))) + geom_polygon(aes(x,y), data = circle_frame, color = "black", fill = NA)  + 
  geom_text(data = correlations2, label = rownames(correlations2))
```
\ 
biplot
\ 
```{r}
biplot(pca, scale = 0)
```

